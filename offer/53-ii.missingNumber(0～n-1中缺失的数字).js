/**
 * 0～n-1中缺失的数字
 * 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。
 * 在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
  var l = 0, r = nums.length - 1;
  while (l <= r) {
    var m = Math.floor((l + r) / 2);
    if (nums[m] === m) {
      l = m + 1;
    } else {
      r = m - 1;
    }
  }
  return l;
};
/**
 * 复杂度分析:
 * 时间复杂度 O(logN)： 二分法为对数级别复杂度。
 * 空间复杂度 O(1)： 几个变量使用常数大小的额外空间。
 * 
 * 边界问题：
 * while循环中使用l<=r，然后返回l
 * 
 * 初始化： 左边界 i=0 ，右边界 j = len(nums)−1 ；代表闭区间 [i,j] 。
 * 循环二分： 当 i≤j 时循环 （即当闭区间 [i,j] 为空时跳出） ；
 *    计算中点 m = (i+j)//2 ，其中 "//" 为向下取整除法；
 *    若 nums[m] = m ，则 “右子数组的首位元素” 一定在闭区间 [m+1,j] 中，因此执行 i=m+1；
 *    若 nums[m] != m ，则 “左子数组的末位元素” 一定在闭区间 [i,m−1] 中，因此执行 j=m−1；
 * 返回值： 跳出时，变量 i 和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可。
 */

 console.log(missingNumber([0,1,2,3,4,5,6,7,9]))
 [0,1,3,4,5,6,7,8,9]